
=begin

	1) сортировка данных в Ruby простая, так как есть встроенные методы
	2) сортировка данных в Ruby простая, так как есть сортировка блоками
		3-1) sort
		3-2) sort_by

=end

# 1) sort (изменяет элементы в порядке возростания)
sample1 = [1,5,4,7,3,2,50,0]
answer1 = sample1.sort
p answer1

# 1) sort (изменяет элементы через блок)
sample2 = [1,5,4,7,3,2,50,0]
answer2 = sample2.sort {
	|a,b|
	b <=> a
}
p answer2

=begin

	sample2 = [1,5,4,7,3,2,50,0]   # [1]
	answer2 = sample2.sort {       # [2]
		|a,b|                      # [3]
		b <=> a                    # [4]
	}                              # [5]

	Сортировка в обратном порядке, т.е. от БОЛЬШЕГО к меньшему
	[1] => массив, который будем сортировать: 1,5,4,7,3,2,50,0
	[2] => новый массив = старый с методом sort и блоком
	[3] => берем два элемента массива
	[4] => оператор <=> (spaceship operator)
		-1, если 1-ый объект меньше 2-го (1 <=> 10)
		 0, если 1-ый объект равен 2-ому (1 <=> 1)
		+1, если 1-ый объект больше 2-го (15 <=> 10)

		5<=>1, сравниваем и получаем +1: значит `b` должно идти перед `a`
		...                           0: значит порядок не меняется
		...                          -1: значит `b` должно идти после `a`

=end


# 2) sort_by (при сортировке сложных объектов)
sample3 = ["pineapple","qiwi","banan","apple","avocado"]
answer3 = sample3.sort_by {
	|elem|
	elem.length
}
p answer3

heros = [
	{ name: "John", age: 45 }, 
	{ name: "Jane", age: 30 }, 
	{ name: "Jim", age: 5 },
	{ name: "Marina", age: 15 },
	{ name: "Polina", age: 16 }
]
puts heros
puts "=================="

heros2 = heros.sort_by {
	|record|
	record[:age]
}
puts heros2


=begin

	а) стабильная сортировка, т.е. элементы с одинаковыми значениями сохраняют свой порядок относительно друг друга 
	б) шварциевские преобразования (Schwartzian Transform), т.е. эффективно для сложных сортировок
		- сначала вычисляется ключ сортировки
		- потом происходит сортировка

=end